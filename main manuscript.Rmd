---
title: "Maximum tree height in the Amazon"
output: html_notebook
---

## Introduction

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

## Material and Methods

```{r, message=FALSE}
require(ggplot2)
require(raster)
require(tidyverse)
require(tmap)
require(sf)
require(leaflet)
require(sp)
require(gridExtra)
require(magrittr)

require(factoextra) 
require(randomForest)
require(caret)
```

Transects and maximum height extraction....

```{r, message=FALSE}
amaz = shapefile('./data/amazbioma.shp')
maximas = sf::as_Spatial(st_read(dsn = './data/maximum height 200222.gpkg', layer = 'pontos_wgs84'))
maximas@data = maximas@data %>% select(3)
tm_shape(amaz) + tm_polygons() + 
  tm_shape(maximas) + tm_dots("altura_cop", size = 0.2, palette = "RdYlGn")
```

Wind speed layers. Two components v-speed and u-speed...

```{r}
uspeed = raster('./data/uspeed_500m.tif')
uspeed = setMinMax(uspeed)
ref = uspeed

tm_shape(uspeed) + tm_raster(n = 10)
```

```{r}
vspeed = raster('./data/vspeed_500m.tif') %>% crop(ref)
vspeed = raster(vals=values(vspeed),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
vspeed = setMinMax(vspeed)

tm_shape(vspeed) + tm_raster(n = 10)
```

The SRTM layer...

```{r}
srtm = raster('./data/srtm_500m.tif') %>% crop(ref)
srtm = raster(vals=values(srtm),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])

srtm[srtm <= 0] = NA
srtm[srtm >= 1000] = NA
srtm = setMinMax(srtm)

tm_shape(srtm) + tm_raster(n = 10)

```

## Results

### Varible importance

Clip environmental variables matching maximum height location...

```{r}
# cria stack das variáveis ambientais
layers = stack(srtm, uspeed, vspeed)
# atualiza nome das camadas
names(layers) = c("srtm", "uspeed", "vspeed")

# extrai valor das variáveis ambientais para cada altura máxima mapeada
explanatoryVariables = extract(layers, maximas)
# exclui o stack de camadas originais
rm(layers)

# adiciona no shapefile das alturas máximas os valores das variáveis ambientais extraídas
maximas@data = cbind(maximas@data, explanatoryVariables)
# exclui dataframe das variáveis ambientais temporária
rm(explanatoryVariables)

# explora graficamente a associação entre altura maxima e variáveis ambientais
plot(maximas@data)
```

Principal components analysis....

```{r}
# separa as variáveis explicativas
input = maximas@data %>% na.omit() %>% select(-altura_cop)
# separa a variável altura maxima
output = maximas@data %>% na.omit() %>% select(altura_cop)
# renomeia a variável
names(output) = c("height")
# normaliza as variáveis explicativas
inputScaled = input %>% preProcess(method = c("center", "scale")) %>% predict(input)
# salvar parâmetros da normalização
normParam = preProcess(input, method = c("center", "scale"))

# ajusta os componentes principais
res.pca = prcomp(inputScaled)                                           
# calcula a correlação da variável dependente e componentes
target.coord = cor(output, res.pca$x) 
# cria biplot
p = fviz_pca_var(res.pca, col.var = "contrib", # Color by contributions to the PC
                 gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
                 repel = TRUE)     # Avoid text overlapping)
# adiciona variável dependente no biplot
fviz_add(p, target.coord, color ="black", geom="arrow")
rm(p, target.coord)
```

### Modeling tree maximum height

Random forest prediction model....

```{r}
# cria base com variável dependente original com independente normalizada
driversScaled = cbind(output, inputScaled)
# limpa variáveis que não serão mais utilizadas
rm(output, input, inputScaled)
# divide os trasectos em k-folds
folds = driversScaled %>% row.names() %>% groupKFold(k = 15)           

# parametriza os parametros de controle da função train do pacote caret
group_fit_control = trainControl(index = folds, method = "cv")     
# define variáveis dependentes e independentes
res.rf = train(height ~ .,                                         
               data = driversScaled, # define base de dados                  
               method='rf',          # define modelo a ser treinado
               importance=T,         # análise de importancia para as variaveis
               trControl = group_fit_control) # parâmetros para validação cruzada

# limpa da memória parâmetros para Random Forest
rm(folds, group_fit_control)

# apresenta importância das variáveis com base nos modelos Random Forest
varImp(res.rf)
```

Normaliza raster para serem input para o modelo ajustado....

```{r}
# normaliza camada uspeed
uspeedScaled = (uspeed - normParam$mean['uspeed']) / normParam$std['uspeed']
# remove raster original uspeed
rm(uspeed)

# normaliza camada vspeed
vspeedScaled = (vspeed - normParam$mean['vspeed']) / normParam$std['vspeed']
# remove raster original uspeed
rm(vspeed)

# normaliza camada uspeed
srtmScaled = (srtm - normParam$mean['srtm']) / normParam$std['srtm']
# remove raster original uspeed
rm(srtm)

scaledLayers = stack(srtmScaled, uspeedScaled, vspeedScaled)
names(scaledLayers) = c("srtm", "uspeed", "vspeed")
rm(srtmScaled, uspeedScaled, vspeedScaled)

```

Aplica Random Forest para stack normalizado...

```{r}

heightRaster = predict(scaledLayers, res.rf)
heightRaster = setMinMax(heightRaster)

tm_shape(heightRaster) + tm_raster()
```

