---
title: "Exploring variables"
output:
  html_document:
    df_print: paged
---

```{r, message=FALSE}
require(ggplot2)
require(raster)
require(tidyverse)
require(tmap)
require(sf)
require(leaflet)
require(sp)
require(gridExtra)
require(magrittr)
require(factoextra) 
require(randomForest)
require(caret)
require(minpack.lm)
```

## Importing maximum height dataset

```{r, message=FALSE}
amaz = shapefile('./data/amazbioma.shp')
maximas = sf::as_Spatial(st_read(dsn = './data/maximum height 200321.gpkg', layer = 'pontos_wgs84'))
maximas@data = maximas@data %>% select(3)
tm_shape(amaz) + tm_polygons() + 
  tm_shape(maximas) + tm_dots("altura_cop", size = 0.2, palette = "RdYlGn")
```

## Importing raster files

### Wind speed

```{javaScript eval=FALSE}
var AMAZ = ee.FeatureCollection("users/egorgens/eba/amazbioma"),
    EBA = ee.FeatureCollection("users/egorgens/eba/maximas_eba"),
    ERA = ee.ImageCollection("ECMWF/ERA5/DAILY");


/* u-wind speed */

var wspeed = ERA
  .select('u_component_of_wind_10m')
  .filterDate('2014-01-01', '2018-12-31')
  .reduce(ee.Reducer.max())
  .clip(AMAZ);

Map.addLayer(wspeed.clip(AMAZ), 
  {min: 1, max: 4, palette: ['blue', 'yellow', 'red']}, 
  'u-speed wind', 
  false);
  
// Export.image.toDrive({
//   image: wspeed.clip(AMAZ),
//   description: 'uspeed_500m',
//   scale: 500,
//   region: AMAZ
// });
  
// Export.image.toAsset({
//   image: wspeed.clip(AMAZ),
//   description: 'uspeed',
//   assetId: 'uspeed',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });

/* v-wind speed */

var vspeed = ERA
  .select('v_component_of_wind_10m')
  .filterDate('2014-01-01', '2018-12-31')
  .reduce(ee.Reducer.max())
  .clip(AMAZ);

Map.addLayer(vspeed.clip(AMAZ), 
  {min: 1, max: 4, palette: ['blue', 'yellow', 'red']}, 
  'v-speed wind', 
  false);

// Export.image.toDrive({
//   image: vspeed.clip(AMAZ),
//   description: 'vspeed_500m',
//   scale: 500,
//   region: AMAZ
// });

// Export.image.toAsset({
//   image: vspeed.clip(AMAZ),
//   description: 'vspeed',
//   assetId: 'vspeed',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });

// chart wind u-speed

var speed2Chart = wspeed.reduceRegions({
  collection: EBA,
  reducer: ee.Reducer.mean(),
  scale: 30,
});

var speedChart = ui.Chart.feature.byFeature(speed2Chart, 'mean', ['altura cop'])
  .setChartType('ScatterChart')
  .setOptions({ pointSize: 2, width: 300, height: 300, 
  titleX: 'u-Speed wind (m/s)', titleY: 'Height (m)', 
  legend: {position: 'none'}});
   
print(speedChart);

// chart wind v-speed

var vspeed2Chart = vspeed.reduceRegions({
  collection: EBA,
  reducer: ee.Reducer.mean(),
  scale: 30,
});

var vspeedChart = ui.Chart.feature.byFeature(vspeed2Chart, 'mean', ['altura cop'])
  .setChartType('ScatterChart')
  .setOptions({ pointSize: 2, width: 300, height: 300, 
  titleX: 'v-Speed wind (m/s)', titleY: 'Height (m)', 
  legend: {position: 'none'}});
   
print(vspeedChart);
```


```{r}
uspeed = raster('./data/uspeed.tif')
uspeed = setMinMax(uspeed)
ref = uspeed

#tm_shape(uspeed) + tm_raster(n = 10)
```


```{r}
vspeed = raster('./data/vspeed.tif') %>% crop(ref)
vspeed = raster(vals=values(vspeed),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
vspeed = setMinMax(vspeed)

#tm_shape(vspeed) + tm_raster(n = 10)
```

### Elevation and freatic access

```{javaScript eval=FALSE}
var AMAZ = ee.FeatureCollection("users/egorgens/eba/amazbioma"),
    EBA = ee.FeatureCollection("users/egorgens/eba/maximas_eba"),
    SRTM = ee.Image("USGS/SRTMGL1_003");
	
/* SRTM 30 metros */

// Map.addLayer(SRTM.clip(AMAZ), 
//   {min: 0, max: 500}, 
//   'SRTM', 
//   false);

Export.image.toDrive({
  image: SRTM.clip(AMAZ),
  description: 'srtm_500m',
  scale: 500,
  region: AMAZ,
  folder: 'export_dominantHeight'
});

// Export.image.toAsset({
//   image: SRTM.clip(AMAZ),
//   description: 'srtm1k',
//   assetId: 'srtm1k',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });

  
//chart srtm 

// var elevation2Chart = SRTM.reduceRegions({
//   collection: EBA,
//   reducer: ee.Reducer.mean(),
//   scale: 30,
// });

// var elevationChart = ui.Chart.feature.byFeature(elevation2Chart, 
//   'mean', 
//   ['altura cop'])
//   .setChartType('ScatterChart')
//   .setOptions({ pointSize: 2, width: 300, height: 300, 
//   titleX: 'Elevation (m)', titleY: 'Height (m)', 
//   legend: {position: 'none'} });
   
// print(elevationChart);  
```

```{r}
srtm = raster('./data/srtm.tif') %>% crop(ref)
srtm = raster(vals=values(srtm),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])

srtm[srtm <= 0] = NA
srtm[srtm >= 1000] = NA
srtm = setMinMax(srtm)

#tm_shape(srtm) + tm_raster(n = 10)

```

### Energy balance

```{javaScript eval=FALSE}
var AMAZ = ee.FeatureCollection("users/egorgens/eba/amazbioma"),
    EBA = ee.FeatureCollection("users/egorgens/eba/maximas_eba"),
    TERRACLIMATE = ee.ImageCollection("IDAHO_EPSCOR/TERRACLIMATE");
    
/* Evapotranspiration */

var pet = TERRACLIMATE 
  .select('pet') 
  .filterDate('1990-01-01', '2016-12-31') 
  .reduce(ee.Reducer.median()); 
  
pet = pet.multiply(0.1);

// Map.addLayer(pet.clip(AMAZ), 
//   {min:79, max:115, palette: ['white', 'yellow', 'blue']}, 
//   'P-PET', 
//   false);

Export.image.toDrive({
  image: pet.clip(AMAZ),
  description: 'pet_500m',
  scale: 500,
  region: AMAZ,
  folder: 'export_dominantHeight'
});

// Export.image.toAsset({
//   image: pet.clip(AMAZ),
//   description: 'pet1k',
//   assetId: 'pet1k',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });

/* Palmer Drought index */

var pdsi = TERRACLIMATE 
  .select('pdsi') 
  .filterDate('1990-01-01', '2016-12-31') 
  .reduce(ee.Reducer.median()); 

pdsi = pdsi.multiply(0.01);

// Map.addLayer(pdsi.clip(AMAZ), 
//   {min:-4, max:4, palette: ['red', 'yellow', 'blue']}, 
//   'Palmer Drought Index', 
//   false);

Export.image.toDrive({
  image: pdsi.clip(AMAZ),
  description: 'pdsi_500m',
  scale: 500,
  region: AMAZ,
  folder: 'export_dominantHeight'
});
  
// Export.image.toAsset({
//   image: pdsi.clip(AMAZ),
//   description: 'pdsi1k',
//   assetId: 'pdsi1k',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });
  
//chart evapotranspiration 

// var pet2Chart = pet.reduceRegions({
//   collection: EBA,
//   reducer: ee.Reducer.mean(),
//   scale: 30,
// });

// var petChart = ui.Chart.feature.byFeature(pet2Chart, 
//   'mean', 
//   ['altura cop'])
//   .setChartType('ScatterChart')
//   .setOptions({ pointSize: 2, width: 300, height: 300, 
//   titleX: 'Average monthly PET', titleY: 'Height (m)', 
//   legend: {position: 'none'} });
   
// print(petChart);

//chart Palmer Drought Index

// var pdsi2Chart = pdsi.reduceRegions({
//   collection: EBA,
//   reducer: ee.Reducer.mean(),
//   scale: 30,
// });

// var pdsiChart = ui.Chart.feature.byFeature(pdsi2Chart, 'mean', ['altura cop'])
//   .setChartType('ScatterChart')
//   .setOptions({ pointSize: 2, width: 300, height: 300, 
//   titleX: 'Average monthly Palmer Drought Index', titleY: 'Height (m)', 
//   legend: {position: 'none'}});
   
// print(pdsiChart);
```


```{r}
pet = raster('./data/pet.tif') %>% crop(ref)
pet = raster(vals=values(pet),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
pet = setMinMax(pet)

#tm_shape(pet) + tm_raster(n = 10)
```

### Radiation

```{javaScript eval=FALSE}
var AMAZ = ee.FeatureCollection("users/egorgens/eba/amazbioma"),
    EBA = ee.FeatureCollection("users/egorgens/eba/maximas_eba"),
    NOAA = ee.ImageCollection("NOAA/CDR/AVHRR/LAI_FAPAR/V4");
    
/* Fraction of absorbed photosynthetic active radiation */

var fpar = NOAA
  .select('FAPAR')
  .filterDate('2016-01-01', '2018-12-31')
  .reduce(ee.Reducer.median());
fpar = fpar.divide(10); 

// Map.addLayer(fpar.clip(AMAZ), 
//   {min: 70.0, max: 90.0, 
//     palette: ['3b0200', '977705', 'ca9f06', 'ffca09', '006a03', '003b02']}, 
//   'FAPAR', 
//   false);

Export.image.toDrive({
  image: fpar.clip(AMAZ),
  description: 'fpar_500m',
  scale: 500,
  region: AMAZ,
  folder: 'export_dominantHeight'
});

// Export.image.toAsset({
//   image: fpar.clip(AMAZ),
//   description: 'fpar1k',
//   assetId: 'fpar1k',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });
  
//chart fpar

// var fpar2Chart = fpar.reduceRegions({
//   collection: EBA,
//   reducer: ee.Reducer.mean(),
//   scale: 30,
// });

// var fparChart = ui.Chart.feature.byFeature(fpar2Chart, 'mean', ['altura cop'])
//   .setChartType('ScatterChart')
//   .setOptions({ pointSize: 2, width: 300, height: 300, 
//   titleX: 'FPAR', titleY: 'Height (m)', 
//   legend: {position: 'none'}});
   
// print(fparChart);
```

```{r}
fapar = raster('./data/fapar.tif') %>% crop(ref)
fapar = raster(vals=values(fapar),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
fapar = setMinMax(fapar)

#tm_shape(fapar) + tm_raster(n = 10)
```

```{javaScript eval=FALSE}
var AMAZ = ee.FeatureCollection("users/egorgens/eba/amazbioma"),
    EBA = ee.FeatureCollection("users/egorgens/eba/maximas_eba"),
    MODIS = ee.ImageCollection("MODIS/006/MOD09GA");

/* Free-Cloudy days */

var getQABits = function(image, start, end, newName) {
    // Compute the bits we need to extract.
    var pattern = 0;
    for (var i = start; i <= end; i++) {
       pattern += Math.pow(2, i);
    }
    return image.select([0], [newName])
                  .bitwiseAnd(pattern)
                  .rightShift(start);
};

var clear = function(image){
  var img = image.clip(AMAZ).select('state_1km');
  return getQABits(img,0,1,'ClearDays').expression("b(0) == 0 || b(0) == 3");
};


var years = ee.List.sequence(2014, 2018);

var clearDays = ee.ImageCollection.fromImages(
  years.map(function(y) {
      return MODIS.filter(ee.Filter.calendarRange(y,y,'year')).map(clear).reduce(ee.Reducer.sum());
}).flatten());

// print(clearDays);

var clearDaysReduced = clearDays.reduce(ee.Reducer.mean());

// Map.addLayer(clearDaysReduced.clip(AMAZ),
//   {min:0,max:365, palette: ['blue', 'yellow', 'red']},
//   'Number of clear days', 
//   true);
  
Export.image.toDrive({
  image: clearDaysReduced.clip(AMAZ),
  description: 'clearDays_500m',
  scale: 500,
  region: AMAZ,
  folder: 'export_dominantHeight'
});
  
// Export.image.toAsset({
//   image: clearDaysReduced.clip(AMAZ),
//   description: 'clearDays',
//   assetId: 'clearDays',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });
  
// chart clear days 

// var cleardays2Chart = clearDaysReduced.reduceRegions({
//   collection: EBA,
//   reducer: ee.Reducer.mean(),
//   scale: 30,
// });

// var clearDaysChart = ui.Chart.feature.byFeature(cleardays2Chart, 
//   'mean', 
//   ['altura cop'])
//   .setChartType('ScatterChart')
//   .setOptions({ pointSize: 2, width: 300, height: 300, 
//   titleX: 'Clear days', titleY: 'Height (m)', 
//   legend: {position: 'none'} });
   
// print(clearDaysChart);
```


```{r}
clearDays = raster('./data/clearDays.tif') %>% crop(ref)
clearDays = raster(vals=values(clearDays),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
clearDays = setMinMax(clearDays)

#tm_shape(clearDays) + tm_raster(n = 10)
```

### Precipitation

```{javaScript eval=FALSE}
var ppt = ee.ImageCollection("UCSB-CHG/CHIRPS/DAILY") 
                  .select('precipitation')
                  .filter(ee.Filter.date('2014-01-01', '2018-12-31'))
                  .filterBounds(AMAZ);

// Computar meses com menos de 100 mm -----------------------------

var months = ee.List.sequence(1, 12);
var years = ee.List.sequence(2014, 2018);

var months100 = ee.ImageCollection.fromImages(
  years.map(function(y) {
    return months.map(function (m) {
      return ppt
        .filter(ee.Filter.calendarRange(y, y, 'year'))
        .filter(ee.Filter.calendarRange(m, m, 'month'))
        .sum()
        .lte(100)
        .set('month', m).set('year', y);
  });
}).flatten());
//print(months100);

var months100Reduced = months100 
  .reduce(ee.Reducer.sum())
  .clip(AMAZ)
  .divide(5);

Export.image.toDrive({
  image: months100Reduced.clip(AMAZ),
  description: 'months100_500m',
  scale: 500,
  region: AMAZ
});

// Export.image.toAsset({
//   image: months100Reduced.clip(AMAZ),
//   description: 'months1001k',
//   assetId: 'months1001k',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });

// Map.addLayer(months100Reduced.clip(AMAZ), 
//   {min: 0, max:6}, 
//   'Months bellow 100 mm',
//   false);

// Computar dias com mais de 20 mm -------------------------

var days20 = ppt.map(function(image) {
    return image.clip(AMAZ).gte(20);
});

// print(days20);

var days20Reduced = days20 
  .reduce(ee.Reducer.sum())
  .clip(AMAZ)
  .divide(5);

// Export.image.toAsset({
//   image: days20Reduced.clip(AMAZ),
//   description: 'days201k',
//   assetId: 'days201k',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });

Export.image.toDrive({
  image: days20Reduced.clip(AMAZ),
  description: 'days20_500m',
  scale: 500,
  region: AMAZ
});

// Map.addLayer(days20Reduced.clip(AMAZ), 
//   {min: 0, max:6}, 
//   'Days greater than 20 mm');

////chart months < 100 mm

// var months1002Chart = months100Reduced.reduceRegions({
//   collection: EBA,
//   reducer: ee.Reducer.mean(),
//   scale: 30,
// });

// var months100Chart = ui.Chart.feature.byFeature(months1002Chart, 
//   'mean', 
//   ['altura cop'])
//   .setChartType('ScatterChart')
//   .setOptions({ pointSize: 2, width: 300, height: 300, 
//   titleX: 'Average # month bellow 100 mm', titleY: 'Height (m)', 
//   legend: {position: 'none'} });
   
// print(months100Chart);

//// char days > 20 mm

// var days202Chart = days20Reduced.reduceRegions({
//   collection: EBA,
//   reducer: ee.Reducer.mean(),
//   scale: 30,
// });

// var days20Chart = ui.Chart.feature.byFeature(days202Chart, 
//   'mean', 
//   ['altura cop'])
//   .setChartType('ScatterChart')
//   .setOptions({ pointSize: 2, width: 300, height: 300, 
//   titleX: 'Average # days above 20 mm', titleY: 'Height (m)', 
//   legend: {position: 'none'} });
   
// print(days20Chart);
```


```{r}
days20 = raster('./data/days20.tif') %>% crop(ref)
days20 = raster(vals=values(days20),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
days20 = setMinMax(days20)

#tm_shape(days20) + tm_raster(n = 10)
```


```{r}
month100 = raster('./data/month100.tif') %>% crop(ref)
month100 = raster(vals=values(month100),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
month100 = setMinMax(month100)

#tm_shape(month100) + tm_raster(n = 10)
```


```{javaScript eval=FALSE}
/* Wordclim */

var WORDCLIM = ee.Image("WORLDCLIM/V1/BIO");

// Camadas utilizadas

var annualTemperature = WORDCLIM.select('bio01').divide(10);
var temperatureSeasonality = WORDCLIM.select('bio04').divide(100);
var temperatureMax = WORDCLIM.select('bio05').divide(10);
var precipitationWettestMonth = WORDCLIM.select('bio13');
var precipitationDriestMonth = WORDCLIM.select('bio14');
var precipitationSeasonality = WORDCLIM.select('bio15');
var annualPrecipitation = WORDCLIM.select('bio12');

// Map.addLayer(annualTemperature.clip(AMAZ), 
//   {min:23.9, max:29.3, palette: ['blue', 'purple', 'cyan', 'green', 'yellow', 'red']}, 
//   'Annual Mean Temperature', 
//   false);
// Map.addLayer(temperatureSeasonality.clip(AMAZ),
//   {min: 0, max: 10, palette: ['blue', 'purple', 'cyan', 'green', 'yellow', 'red']}, 
//   'Temperature Seasonality', 
//   false);
// Map.addLayer(temperatureMax.clip(AMAZ),
//   {min: 30, max: 35, palette: ['blue', 'purple', 'cyan', 'green', 'yellow', 'red']}, 
//   'Maximum Temperature', 
//   false);
// Map.addLayer(precipitationWettestMonth.clip(AMAZ), 
//   {min:20, max:350, palette: ['blue', 'purple', 'cyan', 'green', 'yellow', 'red']}, 
//   "Precip. Wettest Month", 
//   false);
// Map.addLayer(precipitationDriestMonth.clip(AMAZ), 
//   {min:0, max:161, palette: ['blue', 'purple', 'cyan', 'green', 'yellow', 'red']}, 
//   "Precip. Driest Month", 
//   false);
// Map.addLayer(precipitationSeasonality.clip(AMAZ), 
//   {min:7, max:1, palette: ['blue', 'purple', 'cyan', 'green', 'yellow', 'red']}, 
//   "Precip. Seasonality", 
//   false);
// Map.addLayer(annualPrecipitation.clip(AMAZ), 
//   {min:1000, max:4000, palette: ['blue', 'purple', 'cyan', 'green', 'yellow', 'red']}, 
//   "Annual Precip.", 
//   false);

Export.image.toDrive({
  image: annualTemperature.clip(AMAZ),
  description: 'atemp_500m',
  scale: 500,
  region: AMAZ,
  folder: 'export_dominantHeight'
});

Export.image.toDrive({
  image: temperatureSeasonality.clip(AMAZ),
  description: 'stemp_500m',
  scale: 500,
  region: AMAZ,
  folder: 'export_dominantHeight'
});

Export.image.toDrive({
  image: temperatureMax.clip(AMAZ),
  description: 'mtemp_500m',
  scale: 500,
  region: AMAZ,
  folder: 'export_dominantHeight'
});

Export.image.toDrive({
  image: precipitationWettestMonth.clip(AMAZ),
  description: 'wprecip_500m',
  scale: 500,
  region: AMAZ,
  folder: 'export_dominantHeight'
});

Export.image.toDrive({
  image: precipitationDriestMonth.clip(AMAZ),
  description: 'dprecip_500m',
  scale: 500,
  region: AMAZ,
  folder: 'export_dominantHeight'
});

Export.image.toDrive({
  image: precipitationSeasonality.clip(AMAZ),
  description: 'sprecip_500m',
  scale: 500,
  region: AMAZ,
  folder: 'export_dominantHeight'
});

Export.image.toDrive({
  image: annualPrecipitation.clip(AMAZ),
  description: 'aprecip_500m',
  scale: 500,
  region: AMAZ,
  folder: 'export_dominantHeight'
});

//chart precipitation driest month

// Export.image.toAsset({
//   image: precipitationDriestMonth.clip(AMAZ),
//   description: 'pdriest1k',
//   assetId: 'pdriest1k',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });

// var precip2Chart = precipitationDriestMonth.reduceRegions({
//   collection: EBA,
//   reducer: ee.Reducer.mean(),
//   scale: 30,
// });

// var precipChart = ui.Chart.feature.byFeature(precip2Chart, 'mean', ['altura cop'])
//   .setChartType('ScatterChart')
//   .setOptions({ pointSize: 2, width: 300, height: 300, 
//   titleX: 'Precipitation Driest Month (mm)', titleY: 'Height (m)', 
//   legend: {position: 'none'}});
   
// print(precipChart);

//chart precipitation wettest month

// Export.image.toAsset({
//   image: precipitationWettestMonth.clip(AMAZ),
//   description: 'pwettest1k',
//   assetId: 'pwettest1k',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });

// var precipWet2Chart = precipitationWettestMonth.reduceRegions({
//   collection: EBA,
//   reducer: ee.Reducer.mean(),
//   scale: 30,
// });

// var precipWetChart = ui.Chart.feature.byFeature(precipWet2Chart, 'mean', ['altura cop'])
//   .setChartType('ScatterChart')
//   .setOptions({ pointSize: 2, width: 300, height: 300, 
//   titleX: 'Precipitation Wettest Month (mm)', titleY: 'Height (m)', 
//   legend: {position: 'none'}});
   
// print(precipWetChart);

// chart precipitation seasonality

// Export.image.toAsset({
//   image: precipitationSeasonality.clip(AMAZ),
//   description: 'pseason1k',
//   assetId: 'pseason1k',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });

// var precipSazon2Chart = precipitationSeasonality.reduceRegions({
//   collection: EBA,
//   reducer: ee.Reducer.mean(),
//   scale: 30,
// });

// var precipSazonChart = ui.Chart.feature.byFeature(precipSazon2Chart, 'mean', ['altura cop'])
//   .setChartType('ScatterChart')
//   .setOptions({ pointSize: 2, width: 300, height: 300, 
//   titleX: 'Precipitation seasonality (mm)', titleY: 'Height (m)', 
//   legend: {position: 'none'}});
   
// print(precipSazonChart);

//chart annual precipitation

// Export.image.toAsset({
//   image: annualPrecipitation.clip(AMAZ),
//   description: 'pannual1k',
//   assetId: 'pannual1k',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });

// var precipAnnual2Chart = annualPrecipitation.reduceRegions({
//   collection: EBA,
//   reducer: ee.Reducer.mean(),
//   scale: 30,
// });

// var precipAnnualChart = ui.Chart.feature.byFeature(precipAnnual2Chart, 'mean', ['altura cop'])
//   .setChartType('ScatterChart')
//   .setOptions({ pointSize: 2, width: 300, height: 300, 
//   titleX: 'Annual Precipitation (mm)', titleY: 'Height (m)', 
//   legend: {position: 'none'}});
   
// print(precipAnnualChart);

//chart anual temperature

// Export.image.toAsset({
//   image: annualTemperature.clip(AMAZ),
//   description: 'tannual1k',
//   assetId: 'tannual1k',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });

// var annualTemp2Chart = annualTemperature.reduceRegions({
//   collection: EBA,
//   reducer: ee.Reducer.mean(),
//   scale: 30,
// });

// var annualTempChart = ui.Chart.feature.byFeature(annualTemp2Chart, 'mean', ['altura cop'])
//   .setChartType('ScatterChart')
//   .setOptions({ pointSize: 2, width: 300, height: 300, titleX: 'Annual Mean Temperature (°C)', titleY: 'Height (m)', legend: {position: 'none'}});
   
// print(annualTempChart);

//chart temperature seasonality

// Export.image.toAsset({
//   image: temperatureSeasonality.clip(AMAZ),
//   description: 'tseason1k',
//   assetId: 'tseason1k',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });

// var tempSeason2Chart = temperatureSeasonality.reduceRegions({
//   collection: EBA,
//   reducer: ee.Reducer.mean(),
//   scale: 30,
// });

// var tempSeasonChart = ui.Chart.feature.byFeature(tempSeason2Chart, 'mean', ['altura cop'])
//   .setChartType('ScatterChart')
//   .setOptions({ pointSize: 2, width: 300, height: 300, titleX: 'Temperature Seasonality (°C)', titleY: 'Height (m)', legend: {position: 'none'}});
   
// print(tempSeasonChart);

//chart maximum temperature 

// Export.image.toAsset({
//   image: temperatureMax.clip(AMAZ),
//   description: 'tmax1k',
//   assetId: 'tmax1k',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });

// var tempMax2Chart = temperatureMax.reduceRegions({
//   collection: EBA,
//   reducer: ee.Reducer.mean(),
//   scale: 30,
// });

// var tempMaxChart = ui.Chart.feature.byFeature(tempMax2Chart, 'mean', ['altura cop'])
//   .setChartType('ScatterChart')
//   .setOptions({ pointSize: 2, width: 300, height: 300, titleX: 'Maximum Temperature (°C)', titleY: 'Height (m)', legend: {position: 'none'}});
   
// print(tempMaxChart);


```

```{r}
pannual = raster('./data/pannual.tif') %>% crop(ref)
pannual = raster(vals=values(pannual),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
pannual = setMinMax(pannual)

#tm_shape(pannual) + tm_raster(n = 10)
```


```{r}
pdriest = raster('./data/pdriest.tif') %>% crop(ref)
pdriest = raster(vals=values(pdriest),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
pdriest = setMinMax(pdriest)

#tm_shape(pdriest) + tm_raster(n = 10)
```


```{r}
pwettest = raster('./data/pwettest.tif') %>% crop(ref)
pwettest = raster(vals=values(pwettest),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
pwettest = setMinMax(pwettest)

#tm_shape(pwettest) + tm_raster(n = 10)
```


```{r}
pseason = raster('./data/pseason.tif') %>% crop(ref)
pseason = raster(vals=values(pseason),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
pseason = setMinMax(pseason)

#tm_shape(pseason) + tm_raster(n = 10)
```


### Temperature

```{r}
tseason = raster('./data/tseason.tif') %>% crop(ref)
tseason = raster(vals=values(tseason),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
tseason = setMinMax(tseason)

#tm_shape(tseason) + tm_raster(n = 10)
```


```{r}
tannual = raster('./data/tannual.tif') %>% crop(ref)
tannual = raster(vals=values(tannual),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
tannual = setMinMax(tannual)

#tm_shape(tannual) + tm_raster(n = 10)
```


```{r}
tmax = raster('./data/tmax.tif') %>% crop(ref)
tmax = raster(vals=values(tmax),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
tmax = setMinMax(tmax)

#tm_shape(tmax) + tm_raster(n = 10)
```


### Storms

```{javaScript eval=FALSE}

var AMAZ = ee.FeatureCollection("users/egorgens/eba/amazbioma"),
    EBA = ee.FeatureCollection("users/egorgens/eba/maximas_eba"),
    LIGHTNING = ee.Image("users/egorgens/eba/lightning");
    
/* Lightning */

Map.addLayer(LIGHTNING.clip(AMAZ), 
  {min: 0, max: 35, palette: ['white', 'yellow', 'red']}, 
  'Lightning', 
  false);
  
// Export.image.toDrive({
//   image: LIGHTNING.clip(AMAZ),
//   description: 'lightning_500m',
//   scale: 500,
//   region: AMAZ
// });
  
// Export.image.toAsset({
//   image: LIGHTNING.clip(AMAZ),
//   description: 'lightning1k',
//   assetId: 'lightning1k',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });
  
// chart lightning 

var lightning2Chart = LIGHTNING.reduceRegions({
  collection: EBA,
  reducer: ee.Reducer.mean(),
  scale: 30,
});

var lightningChart = ui.Chart.feature.byFeature(lightning2Chart, 
  'mean', 
  ['altura cop'])
  .setChartType('ScatterChart')
  .setOptions({ pointSize: 2, width: 300, height: 300, 
  titleX: 'Lightning (Flash rate)', titleY: 'Height (m)', 
  legend: {position: 'none'} });
   
print(lightningChart);

```

```{r}
lightning = raster('./data/lightning.tif') %>% crop(ref)
lightning = raster(vals=values(lightning),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
lightning = setMinMax(lightning)

#tm_shape(lightning) + tm_raster(n = 10)
```

### Soil information

```{javaScript eval=FALSE}
var AMAZ = ee.FeatureCollection("users/egorgens/eba/amazbioma"),
    EBA = ee.FeatureCollection("users/egorgens/eba/maximas_eba")

var OPENLAND = ee.Image("OpenLandMap/SOL/SOL_WATERCONTENT-33KPA_USDA-4B1C_M/v01");
var OPENLAND2 = ee.Image("OpenLandMap/SOL/SOL_CLAY-WFRACTION_USDA-3A1A1A_M/v02")

// Camadas utilizadas

var waterContent = OPENLAND.select('b30')
var clayContent = OPENLAND2.select('b30')

Map.addLayer(waterContent.clip(AMAZ), 
  {min:0, max:55, palette: ['blue', 'purple', 'cyan', 'green', 'yellow', 'red']}, 
  'Soil Content 30 cm', 
  true);

Map.addLayer(clayContent.clip(AMAZ), 
  {min:0, max:100, palette: ['blue', 'purple', 'cyan', 'green', 'yellow', 'red']}, 
  'Clay Content 30 cm', 
  true);
  
Export.image.toDrive({
  image: waterContent.clip(AMAZ),
  description: 'waterContent30m',
  scale: 500,
  region: AMAZ,
  folder: 'export_dominantHeight'
});

Export.image.toDrive({
  image: clayContent.clip(AMAZ),
  description: 'clayContent30m',
  scale: 500,
  region: AMAZ,
  folder: 'export_dominantHeight'
});

var waterContent2Chart = waterContent.reduceRegions({
  collection: EBA,
  reducer: ee.Reducer.mean(),
  scale: 30,
});

var waterContentChart = ui.Chart.feature.byFeature(waterContent2Chart, 'mean', ['altura cop'])
  .setChartType('ScatterChart')
  .setOptions({ pointSize: 2, width: 300, height: 300, titleX: 'Water Content (%)', titleY: 'Height (m)', legend: {position: 'none'}});
   
print(soilContentChart);


var clayContent2Chart = clayContent.reduceRegions({
  collection: EBA,
  reducer: ee.Reducer.mean(),
  scale: 30,
});

var clayContentChart = ui.Chart.feature.byFeature(clayContent2Chart, 'mean', ['altura cop'])
  .setChartType('ScatterChart')
  .setOptions({ pointSize: 2, width: 300, height: 300, titleX: 'Clay Content (%)', titleY: 'Height (m)', legend: {position: 'none'}});
   
print(clayContentChart);

```

```{r}
clayContent = raster('./data/clayContent30m.tif') %>% crop(ref)
clayContent = raster(vals=values(clayContent),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
clayContent = setMinMax(clayContent)

#tm_shape(clayContent) + tm_raster(n = 10)
```

```{r}
waterContent = raster('./data/waterContent30m.tif') %>% crop(ref)
waterContent = raster(vals=values(waterContent),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
waterContent = setMinMax(waterContent)

#tm_shape(waterContent) + tm_raster(n = 10)
```

### Vegetation quality

```{javaScript eval=FALSE}
var AMAZ = ee.FeatureCollection("users/egorgens/eba/amazbioma"),
    EBA = ee.FeatureCollection("users/egorgens/eba/maximas_eba"),
    NOAA = ee.ImageCollection("NOAA/CDR/AVHRR/LAI_FAPAR/V4");
    
/* Fraction of absorbed photosynthetic active radiation */

var fpar = NOAA
  .select('FAPAR')
  .filterDate('2016-01-01', '2018-12-31')
  .reduce(ee.Reducer.median());
fpar = fpar.divide(10); 

Map.addLayer(fpar.clip(AMAZ), 
  {min: 70.0, max: 90.0, 
    palette: ['3b0200', '977705', 'ca9f06', 'ffca09', '006a03', '003b02']}, 
  'FAPAR', 
  false);

Export.image.toDrive({
  image: fpar.clip(AMAZ),
  description: 'fapar',
  scale: 500,
  region: AMAZ,
  folder: 'export_dominantHeight'
});

// Export.image.toAsset({
//   image: fpar.clip(AMAZ),
//   description: 'fpar1k',
//   assetId: 'fpar1k',
//   scale: 1000,
//   region: AMAZ,
//   maxPixels: 1e10
// });
  
//chart fpar

// var fpar2Chart = fpar.reduceRegions({
//   collection: EBA,
//   reducer: ee.Reducer.mean(),
//   scale: 30,
// });

// var fparChart = ui.Chart.feature.byFeature(fpar2Chart, 'mean', ['altura cop'])
//   .setChartType('ScatterChart')
//   .setOptions({ pointSize: 2, width: 300, height: 300, 
//   titleX: 'FPAR', titleY: 'Height (m)', 
//   legend: {position: 'none'}});
   
// print(fparChart);

```

```{r}
fapar = raster('./data/fapar.tif') %>% crop(ref)
fapar = raster(vals=values(fapar),
              ext=extent(ref), 
              nrows=dim(ref)[1],
              ncols=dim(ref)[2])
fapar = setMinMax(fapar)

#tm_shape(fapar) + tm_raster(n = 10)
```


## Cliping stack by maximum height location

```{r}
# cria stack das variáveis ambientais
layers = stack(srtm, uspeed, vspeed, clearDays, days20, lightning, month100, pannual, pdriest, pet, pseason, pwettest, tannual, tseason, clayContent, waterContent, fapar)

layers = approxNA(layers)

# atualiza nome das camadas
names(layers) = c("srtm", "uspeed", "vspeed", "clearDays", "days20", "lightning", "month100", "pannual", "pdriest", "pet", "pseason", "pwettest", "tannual", "tseason", "clayContent", "waterContent", "fapar")

# extrai valor das variáveis ambientais para cada altura máxima mapeada
explanatoryVariables = extract(layers, maximas)
# exclui o stack de camadas originais
rm(layers)

# adiciona no shapefile das alturas máximas os valores das variáveis ambientais extraídas
maximas@data = cbind(maximas@data, explanatoryVariables)
# exclui dataframe das variáveis ambientais temporária
rm(explanatoryVariables)

# explora graficamente a associação entre altura maxima e variáveis ambientais
#plot(maximas@data)
```

## Principal components analysis

```{r eval = FALSE}
# separa as variáveis explicativas
input = maximas@data %>% na.omit() %>% select(-altura_cop)
# separa a variável altura maxima
output = maximas@data %>% na.omit() %>% select(altura_cop)
# renomeia a variável
names(output) = c("height")
# normaliza as variáveis explicativas
inputScaled = input %>% preProcess(method = c("center", "scale")) %>% predict(input)
# salvar parâmetros da normalização
normParam = preProcess(input, method = c("center", "scale"))

# ajusta os componentes principais
res.pca = prcomp(inputScaled)                                           
#res.pca = prcomp(input)                                           
# calcula a correlação da variável dependente e componentes
target.coord = cor(output, res.pca$x) 
# cria biplot
p = fviz_pca_var(res.pca, col.var = "contrib", # Color by contributions to the PC
                 gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
                 repel = TRUE)     # Avoid text overlapping)
# adiciona variável dependente no biplot
fviz_add(p, target.coord, color ="black", geom="arrow")
rm(p, target.coord)
```


## Efficience frontier by variable

### SRTM

```{r bounderySrtm}

temp = maximas@data
temp = na.omit(temp)

rangeT = range(temp$srtm)
nbins = 20
bins = seq(rangeT[1], rangeT[2], length.out = nbins)

efficientBorder = data.frame()
for(b in seq(1, nbins-1, 1)){
  tempB = temp[temp$srtm > bins[b] & temp$srtm <= bins[b+1],]
  tempB = arrange(tempB, altura_cop)
  efficientBorder = rbind(efficientBorder, tail(tempB, 1))
}

efficientBorderFiltered = data.frame()
n = 0
while(dim(efficientBorder)[1] != dim(efficientBorderFiltered)[1]){
  
  if(n != 0){efficientBorder = arrange(efficientBorderFiltered, srtm)}
  
  efficientBorderFiltered = data.frame()
  efficientBorderFiltered = rbind(efficientBorderFiltered, efficientBorder[1, ])
  efficientBorderFiltered = rbind(efficientBorderFiltered, efficientBorder[ dim(efficientBorder)[1], ])
  for (i in seq(2, dim(efficientBorder)[1]-1, 1)){
    if(efficientBorder[i, "altura_cop"] <= efficientBorder[i+1, "altura_cop"] & efficientBorder[i, "altura_cop"] <= efficientBorder[i-1, "altura_cop"]) {} else {
      efficientBorderFiltered = rbind(efficientBorderFiltered, efficientBorder[i, ])
    }
  }
  n = n+1
}

# chute inicial dos parâmetros
pars <- c(a=10, b=180, d = 10000)
res2 = nlsLM(altura_cop ~ d * ((a/b) * ((srtm/b)^(a-1)) * exp(-(srtm/b)^a)),
            data=efficientBorderFiltered,
            start=pars)

srtmWeibull = function(a = coef(res2)[1], b = coef(res2)[2], d = coef(res2)[3], x){
  return(d*((a/b) * ((x/b)^(a-1)) * exp(-(x/b)^a)))
}

estHeight = data.frame(srtm = seq(min(temp$srtm), max(temp$srtm), length.out = 100), altura_cop = srtmWeibull(x = seq(min(temp$srtm), max(temp$srtm), length.out = 100)))

ggplot(temp, aes(srtm, altura_cop)) + 
  geom_point(colour = 'darkgray') +
  geom_point(data = efficientBorderFiltered, colour = "black") +
  geom_line(data = estHeight, aes(srtm, altura_cop)) +
  xlab('Elevation (m)') + ylab('Height (m)') + ylim(c(0, 100)) +
  theme_bw() + theme(panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(),
                     panel.background = element_blank(), 
                     axis.line = element_line(colour = "black"))

```

### u-Speed

```{r bounderyUspeed}

temp = maximas@data
temp = na.omit(temp)

rangeT = range(temp$uspeed)
nbins = 20
bins = seq(rangeT[1]-0.1, rangeT[2], length.out = nbins)

efficientBorder = data.frame()
for(b in seq(1, nbins-1, 1)){
  tempB = temp[temp$uspeed > bins[b] & temp$uspeed <= bins[b+1],]
  tempB = arrange(tempB, altura_cop)
  efficientBorder = rbind(efficientBorder, tail(tempB, 1))
}

efficientBorderFiltered = data.frame()
n = 0
while(dim(efficientBorder)[1] != dim(efficientBorderFiltered)[1]){
  
  if(n != 0){efficientBorder = arrange(efficientBorderFiltered, uspeed)}
  
  efficientBorderFiltered = data.frame()
  efficientBorderFiltered = rbind(efficientBorderFiltered, efficientBorder[1, ])
  efficientBorderFiltered = rbind(efficientBorderFiltered, efficientBorder[ dim(efficientBorder)[1], ])
  
  for (i in seq(2, dim(efficientBorder)[1]-1, 1)){
    if(efficientBorder[i, "altura_cop"] <= efficientBorder[i+1, "altura_cop"] & efficientBorder[i, "altura_cop"] <= efficientBorder[i-1, "altura_cop"]) {
      
    } else {
      
      efficientBorderFiltered = rbind(efficientBorderFiltered, efficientBorder[i, ])
      
    }
  }
  n = n+1
}

# chute inicial dos parâmetros
res2 = lm(altura_cop ~ uspeed, data=efficientBorderFiltered)
uspeedLm = function(a = coef(res2)[1], b = coef(res2)[2], x){
  return(a + b*x)
}

estHeight = data.frame(uspeed = seq(min(temp$uspeed), max(temp$uspeed), length.out = 100), altura_cop = uspeedLm(x = seq(min(temp$uspeed), max(temp$uspeed), length.out = 100)))

ggplot(temp, aes(uspeed, altura_cop)) + 
  geom_point(colour = 'darkgray') +
  geom_point(data = efficientBorderFiltered, colour = "black") +
  geom_line(data = estHeight, aes(uspeed, altura_cop)) +
  xlab('Speed (m/s)') + ylab('Height (m)') + ylim(c(0, 100)) +
  theme_bw() + theme(panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(),
                     panel.background = element_blank(), 
                     axis.line = element_line(colour = "black"))

```

### v-Speed

```{r bounderyVspeed}

temp = maximas@data
temp = na.omit(temp)

rangeT = range(temp$vspeed)
nbins = 20
bins = seq(rangeT[1]-0.1, rangeT[2], length.out = nbins)

efficientBorder = data.frame()
for(b in seq(1, nbins-1, 1)){
  tempB = temp[temp$vspeed > bins[b] & temp$vspeed <= bins[b+1],]
  tempB = arrange(tempB, altura_cop)
  efficientBorder = rbind(efficientBorder, tail(tempB, 1))
}

efficientBorderFiltered = data.frame()
n = 0
while(dim(efficientBorder)[1] != dim(efficientBorderFiltered)[1]){
  
  if(n != 0){efficientBorder = arrange(efficientBorderFiltered, vspeed)}
  
  efficientBorderFiltered = data.frame()
  efficientBorderFiltered = rbind(efficientBorderFiltered, efficientBorder[1, ])
  efficientBorderFiltered = rbind(efficientBorderFiltered, efficientBorder[ dim(efficientBorder)[1], ])
  
  for (i in seq(2, dim(efficientBorder)[1]-1, 1)){
    if(efficientBorder[i, "altura_cop"] <= efficientBorder[i+1, "altura_cop"] & efficientBorder[i, "altura_cop"] <= efficientBorder[i-1, "altura_cop"]) {
      
    } else {
      
      efficientBorderFiltered = rbind(efficientBorderFiltered, efficientBorder[i, ])
      
    }
  }
  n = n+1
}

# ajuste dos parâmetros weibull
pars <- c(a=1, b=mean(efficientBorderFiltered$vspeed), d = 10000)
res2 = nlsLM(altura_cop ~ d * ((a/b) * ((vspeed/b)^(a-1)) * exp(-(vspeed/b)^a)),
            data=efficientBorderFiltered,
            start=pars)

vspeedWeibull = function(a = coef(res2)[1], b = coef(res2)[2], d = coef(res2)[3], x){
  return(d*((a/b) * ((x/b)^(a-1)) * exp(-(x/b)^a)))
}

estHeight = data.frame(vspeed = seq(min(temp$vspeed), max(temp$vspeed), length.out = 100), altura_cop = vspeedWeibull(x = seq(min(temp$vspeed), max(temp$vspeed), length.out = 100)))

ggplot(temp, aes(vspeed, altura_cop)) + 
  geom_point(colour = 'darkgray') +
  geom_point(data = efficientBorderFiltered, colour = "black") +
  geom_line(data = estHeight, aes(vspeed, altura_cop)) +
  xlab('Speed (m/s)') + ylab('Height (m)') + ylim(c(0, 100)) +
  theme_bw() + theme(panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(),
                     panel.background = element_blank(), 
                     axis.line = element_line(colour = "black"))

```

### Clear days

```{r bounderyCleardays}

temp = maximas@data
temp = na.omit(temp)

rangeT = range(temp$clearDays)
nbins = 20
bins = seq(rangeT[1]-0.1, rangeT[2], length.out = nbins)

efficientBorder = data.frame()
for(b in seq(1, nbins-1, 1)){
  tempB = temp[temp$clearDays > bins[b] & temp$clearDays <= bins[b+1],]
  tempB = arrange(tempB, altura_cop)
  efficientBorder = rbind(efficientBorder, tail(tempB, 1))
}

efficientBorderFiltered = data.frame()
n = 0
while(dim(efficientBorder)[1] != dim(efficientBorderFiltered)[1]){
  
  if(n != 0){efficientBorder = arrange(efficientBorderFiltered, clearDays)}
  
  efficientBorderFiltered = data.frame()
  efficientBorderFiltered = rbind(efficientBorderFiltered, efficientBorder[1, ])
  efficientBorderFiltered = rbind(efficientBorderFiltered, efficientBorder[ dim(efficientBorder)[1], ])
  
  for (i in seq(2, dim(efficientBorder)[1]-1, 1)){
    if(efficientBorder[i, "altura_cop"] <= efficientBorder[i+1, "altura_cop"] & efficientBorder[i, "altura_cop"] <= efficientBorder[i-1, "altura_cop"]) {
      
    } else {
      
      efficientBorderFiltered = rbind(efficientBorderFiltered, efficientBorder[i, ])
      
    }
  }
  n = n+1
}

# ajuste dos parâmetros weibull
pars <- c(a=1, b=mean(efficientBorderFiltered$clearDays), d = 10000)
res2 = nlsLM(altura_cop ~ d * ((a/b) * ((clearDays/b)^(a-1)) * exp(-(clearDays/b)^a)),
            data=efficientBorderFiltered,
            start=pars)

clearDaysWeibull = function(a = coef(res2)[1], b = coef(res2)[2], d = coef(res2)[3], x){
  return(d*((a/b) * ((x/b)^(a-1)) * exp(-(x/b)^a)))
}

estHeight = data.frame(clearDays = seq(min(temp$clearDays), max(temp$clearDays), length.out = 100), altura_cop = clearDaysWeibull(x = seq(min(temp$clearDays), max(temp$clearDays), length.out = 100)))

ggplot(temp, aes(clearDays, altura_cop)) + 
  geom_point(colour = 'darkgray') +
  geom_point(data = efficientBorderFiltered, colour = "black") +
  geom_line(data = estHeight, aes(clearDays, altura_cop)) +
  xlab('Number of clear days (days)') + ylab('Height (m)') + ylim(c(0, 100)) +
  theme_bw() + theme(panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(),
                     panel.background = element_blank(), 
                     axis.line = element_line(colour = "black"))

```

### Days with 20 mm or more

```{r bounderyDays20}

temp = maximas@data
temp = na.omit(temp)

rangeT = range(temp$days20)
nbins = 20
bins = seq(rangeT[1]-0.1, rangeT[2], length.out = nbins)

efficientBorder = data.frame()
for(b in seq(1, nbins-1, 1)){
  tempB = temp[temp$days20 > bins[b] & temp$days20 <= bins[b+1],]
  tempB = arrange(tempB, altura_cop)
  efficientBorder = rbind(efficientBorder, tail(tempB, 1))
}

efficientBorderFiltered = data.frame()
n = 0
while(dim(efficientBorder)[1] != dim(efficientBorderFiltered)[1]){
  
  if(n != 0){efficientBorder = arrange(efficientBorderFiltered, days20)}
  
  efficientBorderFiltered = data.frame()
  efficientBorderFiltered = rbind(efficientBorderFiltered, efficientBorder[1, ])
  efficientBorderFiltered = rbind(efficientBorderFiltered, efficientBorder[ dim(efficientBorder)[1], ])
  
  for (i in seq(2, dim(efficientBorder)[1]-1, 1)){
    if(efficientBorder[i, "altura_cop"] <= efficientBorder[i+1, "altura_cop"] & efficientBorder[i, "altura_cop"] <= efficientBorder[i-1, "altura_cop"]) {
      
    } else {
      
      efficientBorderFiltered = rbind(efficientBorderFiltered, efficientBorder[i, ])
      
    }
  }
  n = n+1
}

# ajuste dos parâmetros weibull
pars <- c(a=1, b=mean(efficientBorderFiltered$days20), d = 10000)
res2 = nlsLM(altura_cop ~ d * ((a/b) * ((days20/b)^(a-1)) * exp(-(days20/b)^a)),
            data=efficientBorderFiltered,
            start=pars)

days20Weibull = function(a = coef(res2)[1], b = coef(res2)[2], d = coef(res2)[3], x){
  return(d*((a/b) * ((x/b)^(a-1)) * exp(-(x/b)^a)))
}

estHeight = data.frame(days20 = seq(min(temp$days20), max(temp$days20), length.out = 100), altura_cop = days20Weibull(x = seq(min(temp$days20), max(temp$days20), length.out = 100)))

ggplot(temp, aes(days20, altura_cop)) + 
  geom_point(colour = 'darkgray') +
  geom_point(data = efficientBorderFiltered, colour = "black") +
  geom_line(data = estHeight, aes(days20, altura_cop)) +
  xlab('Number of days > 20 mm (days)') + ylab('Height (m)') + ylim(c(0, 100)) +
  theme_bw() + theme(panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(),
                     panel.background = element_blank(), 
                     axis.line = element_line(colour = "black"))

```


